[H[JREBOL/Core 2.7.8.4.3 (6-Jan-2011)
Copyright 2011 REBOL Technologies
REBOL is a Trademark of REBOL Technologies
All rights reserved.

Finger protocol loaded
Whois protocol loaded
Daytime protocol loaded
SMTP protocol loaded
ESMTP protocol loaded
POP protocol loaded
IMAP protocol loaded
HTTP protocol loaded
FTP protocol loaded
NNTP protocol loaded
Script: "Red command-line front-end" (none)
Script: "Encap virtual filesystem" (21-Sep-2009)

-=== Red Compiler 0.6.4 ===- 

Compiling /home/nathan/repos/red/opTest.red ...
...using libRedRT built on 9-Apr-2019/22:20:32+1:00

####################
looping over pc
pc: [
    system/script/args: #system [
        #either type = 'exe [stack/push get-cmdline-args] [none/push]
    ] extract-boot-args
]
expr: [
    system/script/args: #system [
        #either type = 'exe [stack/push get-cmdline-args] [none/push]
    ] extract-boot-args
]
in comp-expression
pc in check-infix-operators:
in comp-expression
pc in check-infix-operators:
expr: [
    system/script/args: #system [
        #either type = 'exe [stack/push get-cmdline-args] [none/push]
    ] extract-boot-args
]
 

####################
looping over pc
pc: [extract-boot-args]
expr: [extract-boot-args]
in comp-expression
pc in check-infix-operators:
expr: [extract-boot-args]
 
code: [
    a: context [b: function [x y] [x + y]] 
    probe a/b 4 5
]
##################################################################compiling user code

####################
looping over pc
pc: [
    a: context [b: function [x y] [x + y]] 
    probe a/b 4 5
]
expr: [
    a: context [b: function [x y] [x + y]] 
    probe a/b 4 5
]
in comp-expression
pc in check-infix-operators:

####################
looping over pc
pc: [b: function [x y] [x + y]]
expr: [b: function [x y] [x + y]]
in comp-expression
pc in check-infix-operators:
expr: [b: function [x y] [x + y]]
 
expr: [
    a: context [b: function [x y] [x + y]] 
    probe a/b 4 5
]
 

####################
looping over pc
pc: [
    probe a/b 4 5
]
expr: [
    probe a/b 4 5
]
in comp-expression
pc in check-infix-operators:
in comp-expression
pc in check-infix-operators:
in comp-expression
pc in check-infix-operators:
in comp-expression
pc in check-infix-operators:
expr: [
    probe a/b 4 5
]
 
functions: make hash! [
    make [action! 2 [type [datatype! word!] spec [any-type!]] none] 
    random [action! 1 [{Returns a random value of the same datatype; or shuffles series} value "Maximum value of result (modified when series)" /seed "Restart or randomize" /secure {TBD: Returns a cryptographically secure random number} /only "Pick a random value from a series" return: [any-type!]] [/seed 1 0 /secure 2 0 /only 3 0]] 
    reflect [action! 2 [{Returns internal details about a value via reflection} value [any-type!] field [word!] {spec, body, words, etc. Each datatype defines its own reflectors}] none] 
    to [action! 2 ["Converts to a specified datatype" type [any-type!] "The datatype or example value" spec [any-type!] "The attributes of the new value"] none] 
    form [action! 1 [{Returns a user-friendly string representation of a value} value [any-type!] /part "Limit the length of the result" limit [integer!] return: [string!]] [/part 1 1]] 
    mold [action! 1 [{Returns a source format string representation of a value} value [any-type!] /only "Exclude outer brackets if value is a block" /all "TBD: Return value in loadable format" /flat "TBD: Exclude all indentation" /part "Limit the length of the result" limit [integer!] return: [string!]] [/only 1 0 /all 2 0 /flat 3 0 /part 4 1]] 
    modify [action! 3 ["Change mode for target aggregate value" target [object! series!] field [word!] value [any-type!] /case "Perform a case-sensitive lookup" return: [map! file!]] [/case 1 0]] 
    absolute [action! 1 ["Returns the non-negative value" value [number! char! pair! time!] return: [number! char! pair! time!]] none] 
    add [action! 2 ["Returns the sum of the two values" value1 [number! char! pair! tuple! vector! time! date!] value2 [number! char! pair! tuple! vector! time! date!] return: [number! char! pair! tuple! vector! time! date!]] none] 
    divide [action! 2 ["Returns the quotient of two values" value1 [number! char! pair! tuple! vector! time!] "The dividend (numerator)" value2 [number! char! pair! tuple! vector! time!] "The divisor (denominator)" return: [number! char! pair! tuple! vector! time!]] none] 
    multiply [action! 2 ["Returns the product of two values" value1 [number! char! pair! tuple! vector! time!] value2 [number! char! pair! tuple! vector! time!] return: [number! char! pair! tuple! vector! time!]] none] 
    negate [action! 1 ["Returns the opposite (additive inverse) value" number [number! bitset! pair! time!] return: [number! bitset! pair! time!]] none] 
    power [action! 2 [{Returns a number raised to a given power (exponent)} number [number!] "Base value" exponent [integer! float!] "The power (index) to raise the base value by" return: [number!]] none] 
    remainder [action! 2 [{Returns what is left over when one value is divided by another} value1 [number! char! pair! tuple! vector! time!] value2 [number! char! pair! tuple! vector! time!] return: [number! char! pair! tuple! vector! time!]] none] 
    round [action! 1 [{Returns the nearest integer. Halves round up (away from zero) by default} n [number! time! pair!] /to "Return the nearest multiple of the scale parameter" scale [number!] "Must be a non-zero value" /even "Halves round toward even results" /down {Round toward zero, ignoring discarded digits. (truncate)} /half-down "Halves round toward zero" /floor "Round in negative direction" /ceiling "Round in positive direction" /half-ceiling "Halves round in positive direction"] [/to 1 1 /even 2 0 /down 3 0 /half-down 4 0 /floor 5 0 /ceiling 6 0 /half-ceiling 7 0]] 
    subtract [action! 2 ["Returns the difference between two values" value1 [number! char! pair! tuple! vector! time! date!] value2 [number! char! pair! tuple! vector! time! date!] return: [number! char! pair! tuple! vector! time! date!]] none] 
    even? [action! 1 [{Returns true if the number is evenly divisible by 2} number [number! char! time!] return: [number! char! time!]] none] 
    odd? [action! 1 [{Returns true if the number has a remainder of 1 when divided by 2} number [number! char! time!] return: [number! char! time!]] none] 
    and~ [action! 2 ["Returns the first value ANDed with the second" value1 [logic! integer! char! bitset! binary! typeset! pair! tuple! vector!] value2 [logic! integer! char! bitset! binary! typeset! pair! tuple! vector!] return: [logic! integer! char! bitset! binary! typeset! pair! tuple! vector!]] none] 
    complement [action! 1 [{Returns the opposite (complementing) value of the input value} value [logic! integer! bitset! typeset! binary!] return: [logic! integer! bitset! typeset! binary!]] none] 
    or~ [action! 2 ["Returns the first value ORed with the second" value1 [logic! integer! char! bitset! binary! typeset! pair! tuple! vector!] value2 [logic! integer! char! bitset! binary! typeset! pair! tuple! vector!] return: [logic! integer! char! bitset! binary! typeset! pair! tuple! vector!]] none] 
    xor~ [action! 2 [{Returns the first value exclusive ORed with the second} value1 [logic! integer! char! bitset! binary! typeset! pair! tuple! vector!] value2 [logic! integer! char! bitset! binary! typeset! pair! tuple! vector!] return: [logic! integer! char! bitset! binary! typeset! pair! tuple! vector!]] none] 
    append [action! 2 [{Inserts value(s) at series tail; returns series head} series [series! bitset!] value [any-type!] /part "Limit the number of values inserted" length [number! series!] /only {Insert block types as single values (overrides /part)} /dup "Duplicate the inserted values" count [integer!] return: [series! bitset!]] [/part 1 1 /only 2 0 /dup 3 1]] 
    at [action! 2 ["Returns a series at a given index" series [series!] index [integer! pair!] return: [series!]] none] 
    back [action! 1 ["Returns a series at the previous index" series [series!] return: [series!]] none] 
    change [action! 2 [{Changes a value in a series and returns the series after the change} series [series!] "Series at point to change" value [any-type!] "The new value" /part {Limits the amount to change to a given length or position} range [number! series!] /only "Changes a series as a series." /dup "Duplicates the change a specified number of times" count [number!]] [/part 1 1 /only 2 0 /dup 3 1]] 
    clear [action! 1 [{Removes series values from current index to tail; returns new tail} series [series! bitset! map! none!] return: [series! bitset! map! none!]] none] 
    copy [action! 1 ["Returns a copy of a non-scalar value" value [series! any-object! bitset! map!] /part "Limit the length of the result" length [number! series! pair!] /deep "Copy nested values" /types "Copy only specific types of non-scalar values" kind [datatype!] return: [series! any-object! bitset! map!]] [/part 1 1 /deep 2 0 /types 3 1]] 
    find [action! 2 ["Returns the series where a value is found, or NONE" series [series! bitset! typeset! any-object! map! none!] value [any-type!] /part "Limit the length of the search" length [number! series!] /only "Treat a series search value as a single value" /case "Perform a case-sensitive search" /same {Use "same?" as comparator} /any "TBD: Use * and ? wildcards in string searches" /with "TBD: Use custom wildcards in place of * and ?" wild [string!] /skip "Treat the series as fixed size records" size [integer!] /last "Find the last occurrence of value, from the tail" /reverse {Find the last occurrence of value, from the current index} /tail {Return the tail of the match found, rather than the head} /match {Match at current index only and return tail of match}] [/part 1 1 /only 2 0 /case 3 0 /same 4 0 /any 5 0 /with 6 1 /skip 7 1 /last 8 0 /reverse 9 0 /tail 10 0 /match 11 0]] 
    head [action! 1 ["Returns a series at its first index" series [series!] return: [series!]] none] 
    head? [action! 1 ["Returns true if a series is at its first index" series [series!] return: [logic!]] none] 
    index? [action! 1 [{Returns the current index of series relative to the head, or of word in a context} series [series! any-word!] return: [integer!]] none] 
    insert [action! 2 [{Inserts value(s) at series index; returns series past the insertion} series [series! bitset!] value [any-type!] /part "Limit the number of values inserted" length [number! series!] /only {Insert block types as single values (overrides /part)} /dup "Duplicate the inserted values" count [integer!] return: [series! bitset!]] [/part 1 1 /only 2 0 /dup 3 1]] 
    length? [action! 1 [{Returns the number of values in the series, from the current index to the tail} series [series! bitset! map! tuple! none!] return: [integer! none!]] none] 
    move [action! 2 [{Moves one or more elements from one series to another position or series} origin [series!] target [series!] /part "Limit the number of values inserted" length [integer!] return: [series!]] [/part 1 1]] 
    next [action! 1 ["Returns a series at the next index" series [series!] return: [series!]] none] 
    pick [action! 2 ["Returns the series value at a given index" series [series! bitset! pair! tuple! date! time!] index [scalar! any-string! any-word! block! logic! time!] return: [any-type!]] none] 
    poke [action! 3 [{Replaces the series value at a given index, and returns the new value} series [series! bitset!] index [scalar! any-string! any-word! block! logic!] value [any-type!] return: [series! bitset!]] none] 
    put [action! 3 [{Replaces the value following a key, and returns the new value} series [series! map! object!] key [scalar! any-string! any-word! binary!] value [any-type!] /case "Perform a case-sensitive search" return: [series! map! object!]] [/case 1 0]] 
    remove [action! 1 [{Returns the series at the same index after removing a value} series [series! bitset! none!] /part {Removes a number of values, or values up to the given series index} length [number! char! series!] return: [series! bitset! none!]] [/part 1 1]] 
    reverse [action! 1 [{Reverses the order of elements; returns at same position} series [series! pair! tuple!] /part "Limits to a given length or position" length [number! series!] return: [series! pair! tuple!]] [/part 1 1]] 
    select [action! 2 [{Find a value in a series and return the next value, or NONE} series [series! any-object! map! none!] value [any-type!] /part "Limit the length of the search" length [number! series!] /only "Treat a series search value as a single value" /case "Perform a case-sensitive search" /same {Use "same?" as comparator} /any "TBD: Use * and ? wildcards in string searches" /with "TBD: Use custom wildcards in place of * and ?" wild [string!] /skip "Treat the series as fixed size records" size [integer!] /last "Find the last occurrence of value, from the tail" /reverse {Find the last occurrence of value, from the current index} return: [any-type!]] [/part 1 1 /only 2 0 /case 3 0 /same 4 0 /any 5 0 /with 6 1 /skip 7 1 /last 8 0 /reverse 9 0]] 
    sort [action! 1 [{Sorts a series (modified); default sort order is ascending} series [series!] /case "Perform a case-sensitive sort" /skip "Treat the series as fixed size records" size [integer!] /compare "Comparator offset, block or function" comparator [integer! block! any-function!] /part "Sort only part of a series" length [number! series!] /all "Compare all fields" /reverse "Reverse sort order" /stable "Stable sorting" return: [series!]] [/case 1 0 /skip 2 1 /compare 3 1 /part 4 1 /all 5 0 /reverse 6 0 /stable 7 0]] 
    skip [action! 2 ["Returns the series relative to the current index" series [series!] offset [integer! pair!] return: [series!]] none] 
    swap [action! 2 [{Swaps elements between two series or the same series} series1 [series!] series2 [series!] return: [series!]] none] 
    tail [action! 1 ["Returns a series at the index after its last value" series [series!] return: [series!]] none] 
    tail? [action! 1 ["Returns true if a series is past its last value" series [series!] return: [logic!]] none] 
    take [action! 1 ["Removes and returns one or more elements" series [series! none!] /part "Specifies a length or end position" length [number! series!] /deep "Copy nested values" /last "Take it from the tail end"] [/part 1 1 /deep 2 0 /last 3 0]] 
    trim [action! 1 ["Removes space from a string or NONE from a block" series [series!] /head "Removes only from the head" /tail "Removes only from the tail" /auto "Auto indents lines relative to first line" /lines "Removes all line breaks and extra spaces" /all "Removes all whitespace" /with "Same as /all, but removes characters in 'str'" str [char! string! binary! integer!]] [/head 1 0 /tail 2 0 /auto 3 0 /lines 4 0 /all 5 0 /with 6 1]] 
    delete [action! 1 ["Deletes the specified file or empty folder" file [file!]] none] 
    query [action! 1 ["Returns information about a file" target [file!]] none] 
    read [action! 1 ["Reads from a file, URL, or other port" source [file! url!] /part {Partial read a given number of units (source relative)} length [number!] /seek "Read from a specific position (source relative)" index [number!] /binary "Preserves contents exactly" /lines "Convert to block of strings" /info /as {Read with the specified encoding, default is 'UTF-8} encoding [word!]] [/part 1 1 /seek 2 1 /binary 3 0 /lines 4 0 /info 5 0 /as 6 1]] 
    write [action! 2 ["Writes to a file, URL, or other port" destination [file! url!] data [any-type!] /binary "Preserves contents exactly" /lines "Write each value in a block as a separate line" /info /append "Write data at end of file" /part "Partial write a given number of units" length [number!] /seek "Write at a specific position" index [number!] /allow "Specifies protection attributes" access [block!] /as {Write with the specified encoding, default is 'UTF-8} encoding [word!]] [/binary 1 0 /lines 2 0 /info 3 0 /append 4 0 /part 5 1 /seek 6 1 /allow 7 1 /as 8 1]] 
    if [intrinsic! 2 [{If conditional expression is TRUE, evaluate block; else return NONE} cond [any-type!] then-blk [block!]] none] 
    unless [intrinsic! 2 [{If conditional expression is not TRUE, evaluate block; else return NONE} cond [any-type!] then-blk [block!]] none] 
    either [intrinsic! 3 [{If conditional expression is true, eval true-block; else eval false-blk} cond [any-type!] true-blk [block!] false-blk [block!]] none] 
    any [intrinsic! 1 ["Evaluates, returning at the first that is true" conds [block!]] none] 
    all [intrinsic! 1 ["Evaluates, returning at the first that is not true" conds [block!]] none] 
    while [intrinsic! 2 [{Evaluates body as long as condition block returns TRUE} cond [block!] "Condition block to evaluate on each iteration" body [block!] "Block to evaluate on each iteration"] none] 
    until [intrinsic! 1 ["Evaluates body until it is TRUE" body [block!]] none] 
    loop [intrinsic! 2 ["Evaluates body a number of times" count [integer!] body [block!]] none] 
    repeat [intrinsic! 3 [{Evaluates body a number of times, tracking iteration count} 'word [word!] "Iteration counter; not local to loop" value [integer!] "Number of times to evaluate body" body [block!]] none] 
    forever [intrinsic! 1 ["Evaluates body repeatedly forever" body [block!]] none] 
    foreach [intrinsic! 3 ["Evaluates body for each value in a series" 'word [block! word!] "Word, or words, to set on each iteration" series [series!] body [block!]] none] 
    forall [intrinsic! 2 ["Evaluates body for all values in a series" 'word [word!] "Word referring to series to iterate over" body [block!]] none] 
    remove-each [intrinsic! 3 ["Removes values for each block that returns true" 'word [block! word!] "Word or block of words to set each time" data [series!] "The series to traverse (modified)" body [block!] "Block to evaluate (return TRUE to remove)"] none] 
    func [intrinsic! 2 ["Defines a function with a given spec and body" spec [block!] body [block!]] none] 
    function [intrinsic! 2 [{Defines a function, making all set-words found in body, local} spec [block!] body [block!] /extern "Exclude words that follow this refinement"] [/extern 1 0]] 
    does [intrinsic! 1 [{Defines a function with no arguments or local variables} body [block!]] none] 
    has [intrinsic! 2 [{Defines a function with local variables, but no arguments} vars [block!] body [block!]] none] 
    switch [intrinsic! 2 [{Evaluates the first block following the value found in cases} value [any-type!] "The value to match" cases [block!] /default {Specify a default block, if value is not found in cases} case [block!] "Default block to evaluate"] [/default 1 1]] 
    case [intrinsic! 1 [{Evaluates the block following the first true condition} cases [block!] "Block of condition-block pairs" /all {Test all conditions, evaluating the block following each true condition}] [/all 1 0]] 
    do [native! 1 [{Evaluates a value, returning the last evaluation result} value [any-type!] /expand "Expand directives before evaluation" /args {If value is a script, this will set its system/script/args} arg "Args passed to a script (normally a string)" /next {Do next expression only, return it, update block word} position [word!] "Word updated with new block position"] [/expand 1 0 /args 2 1 /next 3 1]] 
    reduce [intrinsic! 1 [{Returns a copy of a block, evaluating all expressions} value [any-type!] /into {Put results in out block, instead of creating a new block} out [any-block!] "Target block for results, when /into is used"] [/into 1 1]] 
    compose [native! 1 ["Returns a copy of a block, evaluating only parens" value /deep "Compose nested blocks" /only {Compose nested blocks as blocks containing their values} /into {Put results in out block, instead of creating a new block} out [any-block!] "Target block for results, when /into is used"] [/deep 1 0 /only 2 0 /into 3 1]] 
    get [intrinsic! 1 ["Returns the value a word refers to" word [path! word!] /any {If word has no value, return UNSET rather than causing an error} /case "Use case-sensitive comparison (path only)" return: [any-type!]] [/any 1 0 /case 2 0]] 
    set [intrinsic! 2 ["Sets the value(s) one or more words refer to" word [any-word! block! object! path!] "Word, object, map path or block of words to set" value [any-type!] "Value or block of values to assign to words" /any {Allow UNSET as a value rather than causing an error} /case "Use case-sensitive comparison (path only)" /only {Block or object value argument is set as a single value} /some {None values in a block or object value argument, are not set} return: [any-type!]] [/any 1 0 /case 2 0 /only 3 0 /some 4 0]] 
    print [native! 1 ["Outputs a value followed by a newline" value [any-type!]] none] 
    prin [native! 1 ["Outputs a value" value [any-type!]] none] 
    equal? [native! 2 ["Returns TRUE if two values are equal" value1 [any-type!] value2 [any-type!]] none] 
    not-equal? [native! 2 ["Returns TRUE if two values are not equal" value1 [any-type!] value2 [any-type!]] none] 
    strict-equal? [native! 2 [{Returns TRUE if two values are equal, and also the same datatype} value1 [any-type!] value2 [any-type!]] none] 
    lesser? [native! 2 [{Returns TRUE if the first value is less than the second} value1 [any-type!] value2 [any-type!]] none] 
    greater? [native! 2 [{Returns TRUE if the first value is greater than the second} value1 [any-type!] value2 [any-type!]] none] 
    lesser-or-equal? [native! 2 [{Returns TRUE if the first value is less than or equal to the second} value1 [any-type!] value2 [any-type!]] none] 
    greater-or-equal? [native! 2 [{Returns TRUE if the first value is greater than or equal to the second} value1 [any-type!] value2 [any-type!]] none] 
    same? [native! 2 ["Returns TRUE if two values have the same identity" value1 [any-type!] value2 [any-type!]] none] 
    not [native! 1 ["Returns the boolean complement of a value" value [any-type!]] none] 
    type? [native! 1 ["Returns the datatype of a value" value [any-type!] /word "Return a word value, rather than a datatype value"] [/word 1 0]] 
    stats [native! 0 ["Returns interpreter statistics" /show "TBD:" /info "Output formatted results" return: [integer! block!]] [/show 1 0 /info 2 0]] 
    bind [native! 2 ["Bind words to a context; returns rebound words" word [any-word! block!] context [any-object! any-word! function!] /copy "Deep copy blocks before binding" return: [block! any-word!]] [/copy 1 0]] 
    in [native! 2 [{Returns the given word bound to the object's context} object [any-object!] word [any-word!]] none] 
    parse [native! 2 ["Process a series using dialected grammar rules" input [any-block! any-string! binary!] rules [block!] /case "Uses case-sensitive comparison" /part "Limit to a length or position" length [number! series!] /trace callback [function! [
                    event [word!] 
                    match? [logic!] 
                    rule [block!] 
                    input [series!] 
                    stack [block!] 
                    return: [logic!]
                ]] return: [logic! block!]] [/case 1 0 /part 2 1 /trace 3 1]] 
    union [native! 2 ["Returns the union of two data sets" set1 [bitset! block! hash! string! typeset!] set2 [bitset! block! hash! string! typeset!] /case "Use case-sensitive comparison" /skip "Treat the series as fixed size records" size [integer!] return: [block! hash! string! bitset! typeset!]] [/case 1 0 /skip 2 1]] 
    unique [native! 1 ["Returns the data set with duplicates removed" set [block! hash! string!] /case "Use case-sensitive comparison" /skip "Treat the series as fixed size records" size [integer!] return: [block! hash! string!]] [/case 1 0 /skip 2 1]] 
    intersect [native! 2 ["Returns the intersection of two data sets" set1 [bitset! block! hash! string! typeset!] set2 [bitset! block! hash! string! typeset!] /case "Use case-sensitive comparison" /skip "Treat the series as fixed size records" size [integer!] return: [block! hash! string! bitset! typeset!]] [/case 1 0 /skip 2 1]] 
    difference [native! 2 ["Returns the special difference of two data sets" set1 [bitset! block! date! hash! string! typeset!] set2 [bitset! block! date! hash! string! typeset!] /case "Use case-sensitive comparison" /skip "Treat the series as fixed size records" size [integer!] return: [block! hash! string! bitset! typeset!]] [/case 1 0 /skip 2 1]] 
    exclude [native! 2 [{Returns the first data set less the second data set} set1 [bitset! block! hash! string! typeset!] set2 [bitset! block! hash! string! typeset!] /case "Use case-sensitive comparison" /skip "Treat the series as fixed size records" size [integer!] return: [block! hash! string! bitset! typeset!]] [/case 1 0 /skip 2 1]] 
    complement? [native! 1 ["Returns TRUE if the bitset is complemented" bits [bitset!]] none] 
    dehex [native! 1 ["Converts URL-style hex encoded (%xx) strings" value [any-string!] return: [string!] "Always return a string"] none] 
    negative? [native! 1 ["Returns TRUE if the number is negative" number [number! time!]] none] 
    positive? [native! 1 ["Returns TRUE if the number is positive" number [number! time!]] none] 
    max [native! 2 ["Returns the greater of the two values" value1 [scalar! series!] value2 [scalar! series!]] none] 
    min [native! 2 ["Returns the lesser of the two values" value1 [scalar! series!] value2 [scalar! series!]] none] 
    shift [native! 2 [{Perform a bit shift operation. Right shift (decreasing) by default} data [integer!] bits [integer!] /left "Shift bits to the left (increasing)" /logical "Use logical shift (unsigned, fill with zero)" return: [integer!]] [/left 1 0 /logical 2 0]] 
    to-hex [native! 1 [{Converts numeric value to a hex issue! datatype (with leading # and 0's)} value [integer!] /size "Specify number of hex digits in result" length [integer!] return: [issue!]] [/size 1 1]] 
    sine [native! 1 ["Returns the trigonometric sine" angle [number!] /radians "Angle is specified in radians" return: [float!]] [/radians 1 0]] 
    cosine [native! 1 ["Returns the trigonometric cosine" angle [number!] /radians "Angle is specified in radians" return: [float!]] [/radians 1 0]] 
    tangent [native! 1 ["Returns the trigonometric tangent" angle [number!] /radians "Angle is specified in radians" return: [float!]] [/radians 1 0]] 
    arcsine [native! 1 [{Returns the trigonometric arcsine (in degrees by default)} value [number!] /radians "Angle is returned in radians" return: [float!]] [/radians 1 0]] 
    arccosine [native! 1 [{Returns the trigonometric arccosine (in degrees by default)} value [number!] /radians "Angle is returned in radians" return: [float!]] [/radians 1 0]] 
    arctangent [native! 1 [{Returns the trigonometric arctangent (in degrees by default)} value [number!] /radians "Angle is returned in radians" return: [float!]] [/radians 1 0]] 
    arctangent2 [native! 2 [{Returns the smallest angle between the X axis and the point (x,y) (-pi to pi)} y [number!] x [number!] return: [float!]] none] 
    NaN? [native! 1 ["Returns TRUE if the number is Not-a-Number" value [number!] return: [logic!]] none] 
    zero? [native! 1 ["Returns TRUE if the value is zero" value [char! number! pair! time! tuple!] return: [logic!]] none] 
    log-2 [native! 1 ["Return the base-2 logarithm" value [number!] return: [float!]] none] 
    log-10 [native! 1 ["Returns the base-10 logarithm" value [number!] return: [float!]] none] 
    log-e [native! 1 [{Returns the natural (base-E) logarithm of the given value} value [number!] return: [float!]] none] 
    exp [native! 1 [{Raises E (the base of natural logarithm) to the power specified} value [number!] return: [float!]] none] 
    square-root [native! 1 ["Returns the square root of a number" value [number!] return: [float!]] none] 
    construct [intrinsic! 1 [{Makes a new object from an unevaluated spec; standard logic words are evaluated} block [block!] /with "Use a prototype object" object [object!] "Prototype object" /only "Don't evaluate standard logic words"] [/with 1 1 /only 2 0]] 
    value? [native! 1 ["Returns TRUE if the word has a value" value return: [logic!]] none] 
    try [intrinsic! 1 [{Tries to DO a block and returns its value or an error} block [block!] /all {Catch also BREAK, CONTINUE, RETURN, EXIT and THROW exceptions}] [/all 1 0]] 
    uppercase [native! 1 ["Converts string of characters to uppercase" string [any-string! char!] /part "Limits to a given length or position" limit [any-string! number!] return: [any-string! char!]] [/part 1 1]] 
    lowercase [native! 1 ["Converts string of characters to lowercase" string [any-string! char!] /part "Limits to a given length or position" limit [any-string! number!] return: [any-string! char!]] [/part 1 1]] 
    as-pair [native! 2 ["Combine X and Y values into a pair" x [float! integer!] y [float! integer!]] none] 
    break [intrinsic! 0 [{Breaks out of a loop, while, until, repeat, foreach, etc} /return "Forces the loop function to return a value" value [any-type!]] [/return 1 1]] 
    continue [intrinsic! 0 ["Throws control back to top of loop"] none] 
    exit [intrinsic! 0 ["Exits a function, returning no value"] none] 
    return [intrinsic! 1 ["Returns a value from a function" value [any-type!]] none] 
    throw [native! 1 ["Throws control back to a previous catch" value [any-type!] "Value returned from catch" /name "Throws to a named catch" word [word!]] [/name 1 1]] 
    catch [native! 1 ["Catches a throw from a block and returns its value" block [block!] "Block to evaluate" /name "Catches a named throw" word [block! word!] "One or more names"] [/name 1 1]] 
    extend [native! 2 [{Extend an object or map value with list of key and value pairs} obj [map! object!] spec [block! hash! map!] /case "Use case-sensitive comparison"] [/case 1 0]] 
    debase [native! 1 [{Decodes binary-coded string (BASE-64 default) to binary value} value [string!] "The string to decode" /base "Binary base to use" base-value [integer!] "The base to convert from: 64, 58, 16, or 2"] [/base 1 1]] 
    enbase [native! 1 [{Encodes a string into a binary-coded string (BASE-64 default)} value [binary! string!] "If string, will be UTF8 encoded" /base "Binary base to use" base-value [integer!] "The base to convert from: 64, 58, 16, or 2"] [/base 1 1]] 
    to-local-file [native! 1 [{Converts a Red file path to the local system file path} path [file! string!] /full {Prepends current dir for full path (for relative paths only)} return: [string!]] [/full 1 0]] 
    wait [native! 1 ["Waits for a duration in seconds or specified time" value [block! none! number! time!] /all "Returns all events in a block"] [/all 1 0]] 
    checksum [native! 2 ["Computes a checksum, CRC, hash, or HMAC" data [binary! file! string!] method [word!] {MD5 SHA1 SHA256 SHA384 SHA512 CRC32 TCP ADLER32 hash} /with {Extra value for HMAC key or hash table size; not compatible with TCP/CRC32/ADLER32 methods} spec [any-string! binary! integer!] {String or binary for MD5/SHA* HMAC key, integer for hash table size} return: [integer! binary!]] [/with 1 1]] 
    unset [native! 1 ["Unsets the value of a word in its current context" word [block! word!] "Word or block of words"] none] 
    new-line [native! 2 [{Sets or clears the new-line marker within a list series} position [any-list!] "Position to change marker (modified)" value [logic!] "Set TRUE for newline" /all "Set/clear marker to end of series" /skip {Set/clear marker periodically to the end of the series} size [integer!] return: [any-list!]] [/all 1 0 /skip 2 1]] 
    new-line? [native! 1 [{Returns the state of the new-line marker within a list series} position [any-list!] "Position to change marker" return: [any-list!]] none] 
    context? [native! 1 ["Returns the context in which a word is bound" word [any-word!] "Word to check" return: [object! function! none!]] none] 
    set-env [native! 2 [{Sets the value of an operating system environment variable (for current process)} var [any-string! any-word!] "Variable to set" value [none! string!] "Value to set, or NONE to unset it"] none] 
    get-env [native! 1 [{Returns the value of an OS environment variable (for current process)} var [any-string! any-word!] "Variable to get" return: [string! none!]] none] 
    list-env [native! 0 [{Returns a map of OS environment variables (for current process)} return: [map!]] none] 
    now [native! 0 ["Returns date and time" /year "Returns year only" /month "Returns month only" /day "Returns day of the month only" /time "Returns time only" /zone "Returns time zone offset from UTC (GMT) only" /date "Returns date only" /weekday {Returns day of the week as integer (Monday is day 1)} /yearday "Returns day of the year (Julian)" /precise "High precision time" /utc "Universal time (no zone)" return: [date! time! integer!]] [/year 1 0 /month 2 0 /day 3 0 /time 4 0 /zone 5 0 /date 6 0 /weekday 7 0 /yearday 8 0 /precise 9 0 /utc 10 0]] 
    sign? [native! 1 [{Returns sign of N as 1, 0, or -1 (to use as a multiplier)} number [number! time!]] none] 
    as [native! 2 [{Coerce a series into a compatible datatype without copying it} type [any-path! any-string! block! datatype! paren!] "The datatype or example value" spec [any-path! any-string! block! paren!] "The series to coerce"] none] 
    call [native! 1 ["Executes a shell command to run another process" cmd [file! string!] "A shell command or an executable file" /wait "Runs command and waits for exit" /show {Force the display of system's shell window (Windows only)} /console {Runs command with I/O redirected to console (CLI console only at present)} /shell "Forces command to be run from shell" /input in [binary! file! string!] "Redirects in to stdin" /output out [binary! file! string!] "Redirects stdout to out" /error err [binary! file! string!] "Redirects stderr to err" return: [integer!] "0 if success, -1 if error, or a process ID"] [/wait 1 0 /show 2 0 /console 3 0 /shell 4 0 /input 5 1 /output 6 1 /error 7 1]] 
    size? [native! 1 ["Returns the size of a file content" file [file!] return: [integer! none!]] none] 
    browse [native! 1 [{Open web browser to a URL or file mananger to a local file} url [file! url!]] none] 
    decompress [native! 1 [{Decompresses data. Data in GZIP format (RFC 1952) by default} data [binary!] /zlib "Data in ZLIB format (RFC 1950)" size [integer!] "Uncompressed data size" /deflate "Data in DEFLATE format (RFC 1951)" size [integer!] "Uncompressed data size"] [/zlib 1 1 /deflate 2 1]] 
    recycle [native! 0 [/on /off] [/on 1 0 /off 2 0]] 
    quit-return [routine! 1 [
            status [integer!]
        ] none] 
    set-quiet [routine! 2 [
            word [red/cell!] 
            value [red/cell!] 
            /local 
            w [red-word!] 
            type [integer!] 
            node [pointer! [integer!]]
        ] none] 
    shift-right [routine! 2 ["Shift bits to the right" data [integer!] bits [integer!]] none] 
    shift-left [routine! 2 ["Shift bits to the left" data [integer!] bits [integer!]] none] 
    shift-logical [routine! 2 ["Shift bits to the right (unsigned)" data [integer!] bits [integer!]] none] 
    last-lf? [routine! 0 ["Internal Use Only" /local bool [red-logic!]] none] 
    get-current-dir [routine! 0 [] none] 
    set-current-dir [routine! 1 [path [red-string!] /local dir [red-file!]] none] 
    create-dir [routine! 1 [path [red-file!]] none] 
    exists? [routine! 1 [path [red-file!] return: [logic!]] none] 
    os-info [routine! 0 [{Returns detailed operating system version information}] none] 
    as-color [routine! 3 [
            "Combine R, G and B values into a tuple" 
            r [integer!] 
            g [integer!] 
            b [integer!] 
            /local 
            arr1 [integer!] 
            err [integer!]
        ] none] 
    as-ipv4 [routine! 4 [
            "Combine a, b, c and d values into a tuple" 
            a [integer!] 
            b [integer!] 
            c [integer!] 
            d [integer!] 
            /local 
            arr1 [integer!] 
            err [integer!]
        ] none] 
    as-rgba [routine! 4 [
            "Combine a, b, c and d values into a tuple" 
            a [integer!] 
            b [integer!] 
            c [integer!] 
            d [integer!] 
            /local 
            arr1 [integer!] 
            err [integer!]
        ] none] 
    read-clipboard [routine! 0 ["Return the contents of the system clipboard"] none] 
    write-clipboard [routine! 1 ["Write content to the system clipboard" data [red-string!]] none] 
    write-stdout [routine! 1 ["Write data to STDOUT" str [red-string!]] none] 
    routine [function! 2 [{Defines a function with a given Red spec and Red/System body} spec [block!] body [block!]] none] 
    alert [function! 1 [msg [block! string!]] none] 
    also [function! 2 [
            {Returns the first value, but also evaluates the second} 
            value1 [any-type!] 
            value2 [any-type!]
        ] none] 
    attempt [function! 1 [
            {Tries to evaluate a block and returns result or NONE on error} 
            value [block!] 
            /safer "Capture all possible errors and exceptions"
        ] [
            /safer 1 0
        ]] 
    comment [function! 1 ["Consume but don't evaluate the next value" 'value] none] 
    quit [function! 0 [
            "Stops evaluation and exits the program" 
            /return status [integer!] "Return an exit status"
        ] [
            /return 1 1
        ]] 
    empty? [function! 1 [
            "Returns true if a series is at its tail" 
            series [none! series!] 
            return: [logic!]
        ] none] 
    ?? [function! 1 [
            "Prints a word and the value it refers to (molded)" 
            'value [path! word!]
        ] none] 
    probe [function! 1 [
            "Returns a value after printing its molded form" 
            value [any-type!]
        ] none] 
    quote [function! 1 [
            "Return but don't evaluate the next value" 
            :value
        ] none] 
    first [function! 1 ["Returns the first value in a series" s [date! pair! series! time! tuple!]] none] 
    second [function! 1 ["Returns the second value in a series" s [date! pair! series! time! tuple!]] none] 
    third [function! 1 ["Returns the third value in a series" s [date! series! time! tuple!]] none] 
    fourth [function! 1 ["Returns the fourth value in a series" s [date! series! tuple!]] none] 
    fifth [function! 1 ["Returns the fifth value in a series" s [date! series! tuple!]] none] 
    last [function! 1 ["Returns the last value in a series" s [series! tuple!]] none] 
    spec-of [function! 1 [{Returns the spec of a value that supports reflection} value] none] 
    body-of [function! 1 [{Returns the body of a value that supports reflection} value] none] 
    words-of [function! 1 [{Returns the list of words of a value that supports reflection} value] none] 
    class-of [function! 1 ["Returns the class ID of an object" value] none] 
    values-of [function! 1 [{Returns the list of values of a value that supports reflection} value] none] 
    bitset? [function! 1 
        ["Returns true if the value is this type" value [any-type!]] none
    ] 
    binary? [function! 1 
        ["Returns true if the value is this type" value [any-type!]] none
    ] 
    block? [function! 1 
        ["Returns true if the value is this type" value [any-type!]] none
    ] 
    char? [function! 1 
        ["Returns true if the value is this type" value [any-type!]] none
    ] 
    email? [function! 1 
        ["Returns true if the value is this type" value [any-type!]] none
    ] 
    file? [function! 1 
        ["Returns true if the value is this type" value [any-type!]] none
    ] 
    float? [function! 1 
        ["Returns true if the value is this type" value [any-type!]] none
    ] 
    get-path? [function! 1 
        ["Returns true if the value is this type" value [any-type!]] none
    ] 
    get-word? [function! 1 
        ["Returns true if the value is this type" value [any-type!]] none
    ] 
    hash? [function! 1 
        ["Returns true if the value is this type" value [any-type!]] none
    ] 
    integer? [function! 1 
        ["Returns true if the value is this type" value [any-type!]] none
    ] 
    issue? [function! 1 
        ["Returns true if the value is this type" value [any-type!]] none
    ] 
    lit-path? [function! 1 
        ["Returns true if the value is this type" value [any-type!]] none
    ] 
    lit-word? [function! 1 
        ["Returns true if the value is this type" value [any-type!]] none
    ] 
    logic? [function! 1 
        ["Returns true if the value is this type" value [any-type!]] none
    ] 
    map? [function! 1 
        ["Returns true if the value is this type" value [any-type!]] none
    ] 
    none? [function! 1 
        ["Returns true if the value is this type" value [any-type!]] none
    ] 
    pair? [function! 1 
        ["Returns true if the value is this type" value [any-type!]] none
    ] 
    paren? [function! 1 
        ["Returns true if the value is this type" value [any-type!]] none
    ] 
    path? [function! 1 
        ["Returns true if the value is this type" value [any-type!]] none
    ] 
    percent? [function! 1 
        ["Returns true if the value is this type" value [any-type!]] none
    ] 
    refinement? [function! 1 
        ["Returns true if the value is this type" value [any-type!]] none
    ] 
    set-path? [function! 1 
        ["Returns true if the value is this type" value [any-type!]] none
    ] 
    set-word? [function! 1 
        ["Returns true if the value is this type" value [any-type!]] none
    ] 
    string? [function! 1 
        ["Returns true if the value is this type" value [any-type!]] none
    ] 
    tag? [function! 1 
        ["Returns true if the value is this type" value [any-type!]] none
    ] 
    time? [function! 1 
        ["Returns true if the value is this type" value [any-type!]] none
    ] 
    typeset? [function! 1 
        ["Returns true if the value is this type" value [any-type!]] none
    ] 
    tuple? [function! 1 
        ["Returns true if the value is this type" value [any-type!]] none
    ] 
    unset? [function! 1 
        ["Returns true if the value is this type" value [any-type!]] none
    ] 
    url? [function! 1 
        ["Returns true if the value is this type" value [any-type!]] none
    ] 
    word? [function! 1 
        ["Returns true if the value is this type" value [any-type!]] none
    ] 
    image? [function! 1 
        ["Returns true if the value is this type" value [any-type!]] none
    ] 
    date? [function! 1 
        ["Returns true if the value is this type" value [any-type!]] none
    ] 
    handle? [function! 1 
        ["Returns true if the value is this type" value [any-type!]] none
    ] 
    error? [function! 1 
        ["Returns true if the value is this type" value [any-type!]] none
    ] 
    action? [function! 1 
        ["Returns true if the value is this type" value [any-type!]] none
    ] 
    native? [function! 1 
        ["Returns true if the value is this type" value [any-type!]] none
    ] 
    datatype? [function! 1 
        ["Returns true if the value is this type" value [any-type!]] none
    ] 
    function? [function! 1 
        ["Returns true if the value is this type" value [any-type!]] none
    ] 
    object? [function! 1 
        ["Returns true if the value is this type" value [any-type!]] none
    ] 
    op? [function! 1 
        ["Returns true if the value is this type" value [any-type!]] none
    ] 
    routine? [function! 1 
        ["Returns true if the value is this type" value [any-type!]] none
    ] 
    vector? [function! 1 
        ["Returns true if the value is this type" value [any-type!]] none
    ] 
    any-list? [function! 1 ["Returns true if the value is any type of any-list" value [any-type!]] none] 
    any-block? [function! 1 ["Returns true if the value is any type of any-block" value [any-type!]] none] 
    any-function? [function! 1 [{Returns true if the value is any type of any-function} value [any-type!]] none] 
    any-object? [function! 1 [{Returns true if the value is any type of any-object} value [any-type!]] none] 
    any-path? [function! 1 ["Returns true if the value is any type of any-path" value [any-type!]] none] 
    any-string? [function! 1 [{Returns true if the value is any type of any-string} value [any-type!]] none] 
    any-word? [function! 1 ["Returns true if the value is any type of any-word" value [any-type!]] none] 
    series? [function! 1 ["Returns true if the value is any type of series" value [any-type!]] none] 
    number? [function! 1 ["Returns true if the value is any type of number" value [any-type!]] none] 
    immediate? [function! 1 ["Returns true if the value is any type of immediate" value [any-type!]] none] 
    scalar? [function! 1 ["Returns true if the value is any type of scalar" value [any-type!]] none] 
    all-word? [function! 1 ["Returns true if the value is any type of all-word" value [any-type!]] none] 
    to-bitset [function! 1 ["Convert to bitset! value" value] none] 
    to-binary [function! 1 ["Convert to binary! value" value] none] 
    to-block [function! 1 ["Convert to block! value" value] none] 
    to-char [function! 1 ["Convert to char! value" value] none] 
    to-email [function! 1 ["Convert to email! value" value] none] 
    to-file [function! 1 ["Convert to file! value" value] none] 
    to-float [function! 1 ["Convert to float! value" value] none] 
    to-get-path [function! 1 ["Convert to get-path! value" value] none] 
    to-get-word [function! 1 ["Convert to get-word! value" value] none] 
    to-hash [function! 1 ["Convert to hash! value" value] none] 
    to-integer [function! 1 ["Convert to integer! value" value] none] 
    to-issue [function! 1 ["Convert to issue! value" value] none] 
    to-lit-path [function! 1 ["Convert to lit-path! value" value] none] 
    to-lit-word [function! 1 ["Convert to lit-word! value" value] none] 
    to-logic [function! 1 ["Convert to logic! value" value] none] 
    to-map [function! 1 ["Convert to map! value" value] none] 
    to-none [function! 1 ["Convert to none! value" value] none] 
    to-pair [function! 1 ["Convert to pair! value" value] none] 
    to-paren [function! 1 ["Convert to paren! value" value] none] 
    to-path [function! 1 ["Convert to path! value" value] none] 
    to-percent [function! 1 ["Convert to percent! value" value] none] 
    to-refinement [function! 1 ["Convert to refinement! value" value] none] 
    to-set-path [function! 1 ["Convert to set-path! value" value] none] 
    to-set-word [function! 1 ["Convert to set-word! value" value] none] 
    to-string [function! 1 ["Convert to string! value" value] none] 
    to-tag [function! 1 ["Convert to tag! value" value] none] 
    to-time [function! 1 ["Convert to time! value" value] none] 
    to-typeset [function! 1 ["Convert to typeset! value" value] none] 
    to-tuple [function! 1 ["Convert to tuple! value" value] none] 
    to-unset [function! 1 ["Convert to unset! value" value] none] 
    to-url [function! 1 ["Convert to url! value" value] none] 
    to-word [function! 1 ["Convert to word! value" value] none] 
    to-image [function! 1 ["Convert to image! value" value] none] 
    to-date [function! 1 ["Convert to date! value" value] none] 
    context [function! 1 [
            "Makes a new object from an evaluated spec" 
            spec [block!]
        ] none] 
    alter [function! 2 [
            {If a value is not found in a series, append it; otherwise, remove it. Returns true if added} 
            series [series!] 
            value
        ] none] 
    offset? [function! 2 [
            "Returns the offset between two series positions" 
            series1 [series!] 
            series2 [series!]
        ] none] 
    repend [function! 2 [
            {Appends a reduced value to a series and returns the series head} 
            series [series!] 
            value 
            /only "Appends a block value as a block"
        ] [
            /only 1 0
        ]] 
    replace [function! 3 [
            "Replaces values in a series, in place" 
            series [series!] "The series to be modified" 
            pattern "Specific value or parse rule pattern to match" 
            value "New value, replaces pattern in the series" 
            /all "Replace all occurrences, not just the first" 
            /deep "Replace pattern in all sub-lists as well" 
            /case "Case-sensitive replacement" 
            /local p rule s e many? len pos do-parse do-find
        ] [
            /all 1 0 
            /deep 2 0 
            /case 3 0
        ]] 
    math [function! 1 [
            {Evaluates a block using math precedence rules, returning the last result} 
            body [block!] "Block to evaluate" 
            /safe "Returns NONE on error" 
            /local rule pos op sub end
        ] [
            /safe 1 0
        ]] 
    charset [function! 1 [
            "Shortcut for `make bitset!`" 
            spec [block! char! integer! string!]
        ] none] 
    on-parse-event [function! 5 [
            "Standard parse/trace callback used by PARSE-TRACE" 
            event [word!] {Trace events: push, pop, fetch, match, iterate, paren, end} 
            match? [logic!] "Result of last matching operation" 
            rule [block!] "Current rule at current position" 
            input [series!] "Input series at next position to match" 
            stack [block!] "Internal parse rules stack" 
            return: [logic!] {TRUE: continue parsing, FALSE: stop and exit parsing}
        ] none] 
    parse-trace [function! 2 [
            {Wrapper for parse/trace using the default event processor} 
            input [series!] 
            rules [block!] 
            /case "Uses case-sensitive comparison" 
            /part "Limit to a length or position" 
            limit [integer!] 
            return: [logic! block!]
        ] [
            /case 1 0 
            /part 2 1
        ]] 
    suffix? [function! 1 [
            {Returns the suffix (extension) of a filename or url, or NONE if there is no suffix} 
            path [email! file! string! url!]
        ] none] 
    load [function! 1 [
            {Returns a value or block of values by reading and evaluating a source} 
            source [binary! file! string! url!] 
            /header "TBD" 
            /all {Load all values, returns a block. TBD: Don't evaluate Red header} 
            /trap "Load all values, returns [[values] position error]" 
            /next {Load the next value only, updates source series word} 
            position [word!] "Word updated with new series position" 
            /part "Limit to a length or position" 
            length [integer! string!] 
            /into {Put results in out block, instead of creating a new block} 
            out [block!] "Target block for results" 
            /as "Specify the type of data; use NONE to load as code" 
            type [none! word!] "E.g. bmp, gif, jpeg, png" 
            /local codec suffix name mime result
        ] [
            /header 1 0 
            /all 2 0 
            /trap 3 0 
            /next 4 1 
            /part 5 1 
            /into 6 1 
            /as 7 1
        ]] 
    save [function! 2 [
            {Saves a value, block, or other data to a file, URL, binary, or string} 
            where [binary! file! none! string! url!] "Where to save" 
            value "Value(s) to save" 
            /header {Provide a Red header block (or output non-code datatypes)} 
            header-data [block! object!] 
            /all "TBD: Save in serialized format" 
            /length {Save the length of the script content in the header} 
            /as {Specify the format of data; use NONE to save as plain text} 
            format [none! word!] "E.g. bmp, gif, jpeg, png" 
            /local dst codec data suffix find-encoder? name pos header-str k v
        ] [
            /header 1 1 
            /all 2 0 
            /length 3 0 
            /as 4 1
        ]] 
    cause-error [function! 3 [
            {Causes an immediate error throw, with the provided information} 
            err-type [word!] 
            err-id [word!] 
            args [block!] 
            /local type id arg1 arg2 arg3
        ] none] 
    pad [function! 2 [
            "Pad a FORMed value on right side with spaces" 
            str "Value to pad, FORM it if not a string" 
            n [integer!] "Total size (in characters) of the new string" 
            /left "Pad the string on left side" 
            /with "Pad with char" 
            c [char!] 
            return: [string!] "Modified input string at head"
        ] [
            /left 1 0 
            /with 2 1
        ]] 
    mod [function! 2 [
            "Compute a nonnegative remainder of A divided by B" 
            a [char! number! pair! time! tuple! vector!] 
            b [char! number! pair! time! tuple! vector!] "Must be nonzero" 
            return: [number! char! pair! tuple! vector! time!] 
            /local r
        ] none] 
    modulo [function! 2 [
            {Wrapper for MOD that handles errors like REMAINDER. Negligible values (compared to A and B) are rounded to zero} 
            a [char! number! pair! time! tuple! vector!] 
            b [char! number! pair! time! tuple! vector!] 
            return: [number! char! pair! tuple! vector! time!] 
            /local r
        ] none] 
    eval-set-path [function! 1 ["Internal Use Only" value1] none] 
    to-red-file [function! 1 [
            {Converts a local system file path to a Red file path} 
            path [file! string!] 
            return: [file!] 
            /local colon? slash? len i c dst
        ] none] 
    dir? [function! 1 [{Returns TRUE if the value looks like a directory spec} file [file! url!]] none] 
    normalize-dir [function! 1 [
            "Returns an absolute directory spec" 
            dir [file! path! word!]
        ] none] 
    what-dir [function! 0 [
            "Returns the active directory path" 
            /local path
        ] none] 
    change-dir [function! 1 [
            "Changes the active directory path" 
            dir [file! path! word!] {New active directory of relative path to the new one}
        ] none] 
    make-dir [function! 1 [
            {Creates the specified directory. No error if already exists} 
            path [file!] 
            /deep "Create subdirectories too" 
            /local dirs end created dir
        ] [
            /deep 1 0
        ]] 
    extract [function! 2 [
            {Extracts a value from a series at regular intervals} 
            series [series!] 
            width [integer!] "Size of each entry (the skip)" 
            /index "Extract from an offset position" 
            pos [integer!] "The position" 
            /into {Provide an output series instead of creating a new one} 
            output [series!] "Output series"
        ] [
            /index 1 1 
            /into 2 1
        ]] 
    extract-boot-args [function! 0 [
            {Process command-line arguments and store values in system/options (internal usage)} 
            /local args pos unescape len e s
        ] none] 
    collect [function! 1 [
            {Collect in a new block all the values passed to KEEP function from the body block} 
            body [block!] "Block to evaluate" 
            /into {Insert into a buffer instead (returns position after insert)} 
            collected [series!] "The buffer series (modified)" 
            /local keep rule pos
        ] [
            /into 1 1
        ]] 
    flip-exe-flag [function! 1 [
            {Flip the sub-system for the red.exe between console and GUI modes (Windows only)} 
            path [file!] "Path to the red.exe" 
            /local file buffer flag
        ] none] 
    split [function! 2 [
            {Break a string series into pieces using the provided delimiters} 
            series [any-string!] dlm [bitset! char! string!] /local s 
            num
        ] none] 
    dirize [function! 1 [
            "Returns a copy of the path turned into a directory" 
            path [file! string! url!]
        ] none] 
    clean-path [function! 1 [
            {Cleans-up '.' and '..' in path; returns the cleaned path} 
            file [file! string! url!] 
            /only "Do not prepend current directory" 
            /dir "Add a trailing / if missing" 
            /local out cnt f not-file?
        ] [
            /only 1 0 
            /dir 2 0
        ]] 
    split-path [function! 1 [
            {Splits a file or URL path. Returns a block containing path and target} 
            target [file! url!] 
            /local dir pos
        ] none] 
    do-file [function! 1 ["Internal Use Only" file [file! url!] /local saved code new-path src] none] 
    path-thru [function! 1 [
            "Returns the local disk cache path of a remote file" 
            url [url!] "Remote file address" 
            return: [file!] 
            /local so hash file path
        ] none] 
    exists-thru? [function! 1 [
            {Returns true if the remote file is present in the local disk cache} 
            url [file! url!] "Remote file address"
        ] none] 
    read-thru [function! 1 [
            "Reads a remote file through local disk cache" 
            url [url!] "Remote file address" 
            /update "Force a cache update" 
            /binary "Use binary mode" 
            /local path data
        ] [
            /update 1 0 
            /binary 2 0
        ]] 
    load-thru [function! 1 [
            "Loads a remote file through local disk cache" 
            url [url!] "Remote file address" 
            /update "Force a cache update" 
            /as "Specify the type of data; use NONE to load as code" 
            type [none! word!] "E.g. bmp, gif, jpeg, png" 
            /local path file
        ] [
            /update 1 0 
            /as 2 1
        ]] 
    do-thru [function! 1 [
            {Evaluates a remote Red script through local disk cache} 
            url [url!] "Remote file address" 
            /update "Force a cache update"
        ] [
            /update 1 0
        ]] 
    cos [function! 1 [
            "Returns the trigonometric cosine" 
            angle [float!] "Angle in radians"
        ] none] 
    sin [function! 1 [
            "Returns the trigonometric sine" 
            angle [float!] "Angle in radians"
        ] none] 
    tan [function! 1 [
            "Returns the trigonometric tangent" 
            angle [float!] "Angle in radians"
        ] none] 
    acos [function! 1 [
            "Returns the trigonometric arccosine" 
            angle [float!] "Angle in radians"
        ] none] 
    asin [function! 1 [
            "Returns the trigonometric arcsine" 
            angle [float!] "Angle in radians"
        ] none] 
    atan [function! 1 [
            "Returns the trigonometric arctangent" 
            angle [float!] "Angle in radians"
        ] none] 
    atan2 [function! 2 [
            "Returns the angle of the point y/x in radians" 
            y [number!] 
            x [number!] 
            return: [float!]
        ] none] 
    sqrt [function! 1 [
            "Returns the square root of a number" 
            number [number!] 
            return: [float!]
        ] none] 
    to-UTC-date [function! 1 [
            "Returns the date with UTC zone" 
            date [date!] 
            return: [date!]
        ] none] 
    to-local-date [function! 1 [
            "Returns the date with local zone" 
            date [date!] 
            return: [date!]
        ] none] 
    rejoin [function! 1 [
            "Reduces and joins a block of values." 
            block [block!] "Values to reduce and join"
        ] none] 
    sum [function! 1 [
            "Returns the sum of all values in a block" 
            values [block! hash! paren! vector!] 
            /local result value
        ] none] 
    average [function! 1 [
            "Returns the average of all values in a block" 
            block [block! hash! paren! vector!]
        ] none] 
    keys-of [function! 1 [{Returns the list of words of a value that supports reflection} value] none] 
    object [function! 1 [
            "Makes a new object from an evaluated spec" 
            spec [block!]
        ] none] 
    halt [function! 0 [
            "Stops evaluation and exits the program" 
            /return status [integer!] "Return an exit status"
        ] [
            /return 1 1
        ]] 
    ctx209~platform [function! 0 ["Return a word identifying the operating system"] none] 
    ctx238~interpreted? [function! 0 ["Return TRUE if called from the interpreter"] none] 
    ctx249~on-change* [function! 3 [word old new] none] 
    ctx247~on-change* [function! 3 [word old new] none] 
    ctx247~on-deep-change* [function! 7 [owner word target action new index part] none] 
    ctx264~throw-error [function! 1 [spec [block!] /missing 
            /local type src pos
        ] [/missing 1 0]] 
    ctx264~make-hm [routine! 2 [h [integer!] m [integer!]] none] 
    ctx264~make-msf [routine! 2 [m [integer!] s [float!]] none] 
    ctx264~make-hms [routine! 3 [h [integer!] m [integer!] s [integer!]] none] 
    ctx264~make-hmsf [routine! 3 [h [integer!] m [integer!] s [float!]] none] 
    ctx264~make-time [function! 5 [
            pos [string!] 
            hours [integer! none!] 
            mins [integer!] 
            secs [float! integer! none!] 
            neg? [logic!] 
            return: [time!] 
            /local time
        ] none] 
    ctx264~make-binary [routine! 3 [
            start [red-string!] 
            end [red-string!] 
            base [integer!] 
            /local 
            s [red/series-buffer!] 
            p [pointer! [byte!]] 
            len [integer!] 
            unit [integer!] 
            ret [red-binary!]
        ] none] 
    ctx264~make-tuple [routine! 2 [
            start [red-string!] 
            end [red-string!] 
            /local 
            s [red/series-buffer!] 
            err [integer!] 
            len [integer!] 
            unit [integer!] 
            p [pointer! [byte!]] 
            tp [pointer! [byte!]] 
            ret [red/cell!]
        ] none] 
    ctx264~make-number [routine! 3 [
            start [red-string!] 
            end [red-string!] 
            type [red-datatype!] 
            /local 
            s [red/series-buffer!] 
            len [integer!] 
            unit [integer!] 
            p [pointer! [byte!]] 
            err [integer!] 
            i [integer!]
        ] none] 
    ctx264~make-float [routine! 3 [
            start [red-string!] 
            end [red-string!] 
            type [red-datatype!] 
            /local 
            s [red/series-buffer!] 
            unit [integer!] 
            len [integer!] 
            p [pointer! [byte!]] 
            err [integer!] 
            f [float!]
        ] none] 
    ctx264~make-hexa [routine! 2 [
            start [red-string!] 
            end [red-string!] 
            return: [integer!] 
            /local 
            s [red/series-buffer!] 
            unit [integer!] 
            p [pointer! [byte!]] 
            head [pointer! [byte!]] 
            p4 [pointer! [integer!]] 
            n [integer!] 
            power [integer!] 
            cp [byte!]
        ] none] 
    ctx264~make-char [routine! 2 [
            start [red-string!] 
            end [red-string!] 
            /local 
            n [integer!] 
            value [red/cell!]
        ] none] 
    ctx264~push-path [routine! 2 [
            stack [red-block!] 
            type [red-datatype!] 
            /local 
            path [red-path!]
        ] none] 
    ctx264~set-path [routine! 1 [
            stack [red-block!] 
            /local 
            path [red-path!]
        ] none] 
    ctx264~make-word [routine! 2 [
            src [red-string!] 
            type [red-datatype!]
        ] none] 
    ctx264~to-word [function! 3 [
            stack [block!] 
            src [string!] 
            type [datatype!]
        ] none] 
    ctx264~pop [function! 1 [stack [block!] 
            /local value pos
        ] none] 
    ctx264~store [function! 2 [stack [block!] value 
            /local pos
        ] none] 
    ctx264~new-line [routine! 1 [
            series [red/cell!] 
            /local 
            blk [red-block!] 
            s [red/series-buffer!] 
            cell [red/cell!]
        ] none] 
    ctx264~transcode [function! 3 [
            src [string!] 
            dst [block! none!] 
            trap [logic!] 
            /one 
            /only 
            /part 
            length [integer! string!] 
            return: [block!] 
            /local 
            new s e c pos value cnt type process path 
            digit hexa-upper hexa-lower hexa hexa-char not-word-char not-word-1st 
            not-file-char not-str-char not-mstr-char caret-char 
            non-printable-char integer-end ws-ASCII ws-U+2k control-char 
            four half non-zero path-end base base64-char slash-end not-url-char 
            email-end pair-end file-end err date-sep time-sep not-tag-1st 
            cs stack count? old-line line make-string len make-file buffer month-rule m mon-rule list p byte ws newline-char counted-newline ws-no-count escaped-char char-rule line-string nested-curly-braces multiline-string string-rule tag-rule email-rule base-2-rule base-16-rule base-64-rule binary-rule file-rule url-rule symbol-rule ot begin-symbol-rule path-rule special-words word-rule get-word-rule lit-word-rule issue-rule refinement-rule sticky-word-rule hexa-rule tuple-value-rule tuple-rule time-rule value2 day-year-rule year day date-rule ee month date sep hour mn sec neg? zone positive-integer-rule integer-number-rule integer-rule float-special float-exp-rule float-number-rule float-rule map-rule block-rule paren-rule escaped-rule comment-rule wrong-end ending literal-value one-value any-value red-rules
        ] [
            /one 1 0 
            /only 2 0 
            /part 3 1
        ]] 
    + [op! 2 ["Returns the sum of the two values" value1 [number! char! pair! tuple! vector! time! date!] value2 [number! char! pair! tuple! vector! time! date!] return: [number! char! pair! tuple! vector! time! date!]] none] 
    - [op! 2 ["Returns the difference between two values" value1 [number! char! pair! tuple! vector! time! date!] value2 [number! char! pair! tuple! vector! time! date!] return: [number! char! pair! tuple! vector! time! date!]] none] 
    * [op! 2 ["Returns the product of two values" value1 [number! char! pair! tuple! vector! time!] value2 [number! char! pair! tuple! vector! time!] return: [number! char! pair! tuple! vector! time!]] none] 
    / [op! 2 ["Returns the quotient of two values" value1 [number! char! pair! tuple! vector! time!] "The dividend (numerator)" value2 [number! char! pair! tuple! vector! time!] "The divisor (denominator)" return: [number! char! pair! tuple! vector! time!]] none] 
    // [op! 2 [
            {Wrapper for MOD that handles errors like REMAINDER. Negligible values (compared to A and B) are rounded to zero} 
            a [char! number! pair! time! tuple! vector!] 
            b [char! number! pair! time! tuple! vector!] 
            return: [number! char! pair! tuple! vector! time!] 
            /local r
        ] none] % [op! 2 [{Returns what is left over when one value is divided by another} value1 [number! char! pair! tuple! vector! time!] value2 [number! char! pair! tuple! vector! time!] return: [number! char! pair! tuple! vector! time!]] none] 
    = [op! 2 ["Returns TRUE if two values are equal" value1 [any-type!] value2 [any-type!]] none] 
    <> [op! 2 ["Returns TRUE if two values are not equal" value1 [any-type!] value2 [any-type!]] none] 
    == [op! 2 [{Returns TRUE if two values are equal, and also the same datatype} value1 [any-type!] value2 [any-type!]] none] 
    =? [op! 2 ["Returns TRUE if two values have the same identity" value1 [any-type!] value2 [any-type!]] none] 
    < [op! 2 [{Returns TRUE if the first value is less than the second} value1 [any-type!] value2 [any-type!]] none] 
    > [op! 2 [{Returns TRUE if the first value is greater than the second} value1 [any-type!] value2 [any-type!]] none] 
    <= [op! 2 [{Returns TRUE if the first value is less than or equal to the second} value1 [any-type!] value2 [any-type!]] none] 
    >= [op! 2 [{Returns TRUE if the first value is greater than or equal to the second} value1 [any-type!] value2 [any-type!]] none] 
    << [op! 2 ["Shift bits to the left" data [integer!] bits [integer!]] none] 
    >> [op! 2 ["Shift bits to the right" data [integer!] bits [integer!]] none] >>> [op! 2 ["Shift bits to the right (unsigned)" data [integer!] bits [integer!]] none] 
    ** [op! 2 [{Returns a number raised to a given power (exponent)} number [number!] "Base value" exponent [integer! float!] "The power (index) to raise the base value by" return: [number!]] none] 
    and [op! 2 ["Returns the first value ANDed with the second" value1 [logic! integer! char! bitset! binary! typeset! pair! tuple! vector!] value2 [logic! integer! char! bitset! binary! typeset! pair! tuple! vector!] return: [logic! integer! char! bitset! binary! typeset! pair! tuple! vector!]] none] 
    or [op! 2 ["Returns the first value ORed with the second" value1 [logic! integer! char! bitset! binary! typeset! pair! tuple! vector!] value2 [logic! integer! char! bitset! binary! typeset! pair! tuple! vector!] return: [logic! integer! char! bitset! binary! typeset! pair! tuple! vector!]] none] 
    xor [op! 2 [{Returns the first value exclusive ORed with the second} value1 [logic! integer! char! bitset! binary! typeset! pair! tuple! vector!] value2 [logic! integer! char! bitset! binary! typeset! pair! tuple! vector!] return: [logic! integer! char! bitset! binary! typeset! pair! tuple! vector!]] none] 
    ctx272~encode [routine! 2 [img [red-image!] where [red/cell!]] none] 
    ctx272~decode [routine! 1 [data [red/cell!]] none] 
    ctx275~encode [routine! 2 [img [red-image!] where [red/cell!]] none] 
    ctx275~decode [routine! 1 [data [red/cell!]] none] 
    ctx278~encode [routine! 2 [img [red-image!] where [red/cell!]] none] 
    ctx278~decode [routine! 1 [data [red/cell!]] none] 
    ctx281~encode [routine! 2 [img [red-image!] where [red/cell!]] none] 
    ctx281~decode [routine! 1 [data [red/cell!]] none] 
    ctx284~on-change* [function! 3 [word old new 
            /local srs
        ] none] 
    ctx287~on-change* [function! 3 [word old new 
            /local srs
        ] none] 
    ctx287~on-deep-change* [function! 7 [owner word target action new index part] none] 
    ctx290~eval [function! 1 [code [block!] /safe 
            /local result
        ] [/safe 1 0]] 
    ctx290~eval-reaction [function! 3 [reactor [object!] reaction [block! function!] target] none] 
    ctx290~pending? [function! 3 [reactor [object!] reaction [block! function!] type [word!] 
            /local step p
        ] none] 
    ctx290~check [function! 1 [reactor [object!] /only field [set-word! word!] 
            /local pos reaction q
        ] [/only 1 1]] 
    stop-reactor [function! 1 [
            face [object!] 
            /deep 
            /local list pos f
        ] [
            /deep 1 0
        ] ctx290] 
    clear-reactions [function! 0 ["Removes all reactive relations"] none ctx290] 
    dump-reactions [function! 0 [
            {Output all the current reactive relations for debugging purpose} 
            /local limit count obj field reaction target list
        ] none ctx290] 
    ctx290~is~ [function! 2 [
            {Defines a reactive relation whose result is assigned to a word} 
            'field [set-word!] {Set-word which will get set to the result of the reaction} 
            reaction [block!] "Reactive relation" 
            /local words obj rule item
        ] none ctx290] 
    is [op! 2 [
            {Defines a reactive relation whose result is assigned to a word} 
            'field [set-word!] {Set-word which will get set to the result of the reaction} 
            reaction [block!] "Reactive relation" 
            /local words obj rule item
        ] none] 
    react? [function! 2 [
            {Returns a reactive relation if an object's field is a reactive source} 
            reactor [object!] "Object to check" 
            field [word!] "Field to check" 
            /target "Check if it's a target instead of a source" 
            return: [block! function! word! none!] "Returns reaction, type or NONE" 
            /local pos
        ] [
            /target 1 0
        ] ctx290] 
    react [function! 1 [
            {Defines a new reactive relation between two or more objects} 
            reaction [block! function!] "Reactive relation" 
            /link "Link objects together using a reactive relation" 
            objects [block!] "Objects to link together" 
            /unlink "Removes an existing reactive relation" 
            src [block! object! word!] "'all word, or a reactor or a list of reactors" 
            /later "Run the reaction on next change instead of now" 
            /with "Specifies an optional face object (internal use)" 
            ctx [none! object! set-word!] "Optional context for VID faces or target set-word" 
            return: [block! function! none!] {The reactive relation or NONE if no relation was processed} 
            /local objs found? rule item pos obj saved part path
        ] [
            /link 1 1 
            /unlink 2 1 
            /later 3 0 
            /with 4 1
        ] ctx290] 
    ctx302~do-quit [function! 0 [] none] 
    ctx302~throw-error [function! 3 [error [error!] cmd [issue!] code [block!] /local w] none] 
    ctx302~syntax-error [function! 2 [s [block! paren!] e [block! paren!]] none] 
    ctx302~do-safe [function! 1 [code [block! paren!] /manual /with cmd [issue!] /local res t? src] [/manual 1 0 /with 2 1]] 
    ctx302~do-code [function! 2 [code [block! paren!] cmd [issue!] /local p] none] 
    ctx302~count-args [function! 1 [spec [block!] /local total] none] 
    ctx302~func-arity? [function! 1 [spec [block!] /with path [path!] /local arity pos] [/with 1 1]] 
    ctx302~fetch-next [function! 1 [code [block! paren!] /local base arity value path] none] 
    ctx302~eval [function! 2 [code [block! paren!] cmd [issue!] /local after expr] none] 
    ctx302~do-macro [function! 3 [name pos [block! paren!] arity [integer!] /local cmd saved p v res] none] 
    ctx302~register-macro [function! 1 [spec [block!] /local cnt rule p name macro pos valid? named?] none] 
    ctx302~reset [function! 1 [job [none! object!]] none] 
    ctx302~expand [function! 2 [
            code [block!] job [none! object!] 
            /clean 
            /local rule e pos cond value then else cases body keep? expr src saved file
        ] [
            /clean 1 0
        ]] 
    expand-directives [function! 1 [
            {Invokes the preprocessor on argument list, modifying and returning it} 
            code [block! paren!] "List of Red values to preprocess" 
            /clean "Clear all previously created macros and words" 
            /local job
        ] [
            /clean 1 0
        ] ctx302] 
    image?||318 [function! 1 [value [any-type!]] none] 
    keep [function! 1 [v /only] [/only 1 0]] ctx357~b [function! 2 [x y] none]
]
"output2d:"
output: [
    stack/mark-native ~set 
    word/push ~datatype! 
    datatype/push TYPE_DATATYPE 
    word/set 
    stack/unwind 
    stack/reset 
    #script %/home/nathan/repos/red/opTest.red 
    #either type = 'exe [stack/push get-cmdline-args] [none/push] 
    #script %/home/nathan/repos/red/opTest.red 
    either all [
        object/unchanged? ~system 210 
        object/unchanged2? ctx209 12 255
    ] [word/set-in-ctx ctx254 4] [
        stack/mark-func ~eval-set-path exec/ctx175 
        if stack/arguments > stack/bottom [stack/push stack/arguments - 1] 
        object/path-parent/header: TYPE_NONE 
        set-path* eval-path _context/get ~system as cell! ~script as cell! ~args 
        stack/unwind
    ] 
    stack/reset ------------| {system/script/args: #system [ #either type = 'exe ...} 
    stack/mark-func ~extract-boot-args exec/ctx183 
    f_extract-boot-args 
    stack/unwind ------------| "extract-boot-args" #user-code ------------| "a: context [b]" 
    stack/mark-native ~body 
    stack/mark-native ~set 
    _function/push get-root 2 get-root 3 ctx359 as integer! :f_ctx357~b ctx357 
    word/set-in ctx357 0 
    stack/unwind ------------| "b: function [x y] [x + y]" 
    stack/revert 
    stack/mark-native ~set 
    word/push ~a 
    object/init-push ctx357 358 false 
    word/set 
    stack/unwind 
    stack/reset ------------| "a: context [b: function [x y] [x + y]]" 
    stack/mark-func ~probe exec/ctx56 
    stack/mark-func ~b exec/ctx359 
    integer/push 4 
    integer/push 5 
    f_ctx357~b ctx357 
    stack/unwind 
    f_probe 
    stack/unwind ------------| "probe a/b 4 5"
]

####################
looping over pc
pc: [x + y]
expr: [x + y]
in comp-expression
pc in check-infix-operators:
in comp-expression
in comp-expression
expr: [x + y]
 
[------------| "a: context [b]" 
    stack/mark-native ~body 
    stack/mark-native ~set 
    _function/push get-root 2 get-root 3 ctx359 as integer! :f_ctx357~b ctx357 
    word/set-in ctx357 0 
    stack/unwind ------------| "b: function [x y] [x + y]" 
    stack/revert 
    stack/mark-native ~set 
    word/push ~a 
    object/init-push ctx357 358 false 
    word/set 
    stack/unwind 
    stack/reset ------------| "a: context [b: function [x y] [x + y]]" 
    stack/mark-func ~probe exec/ctx56 
    stack/mark-func ~b exec/ctx359 
    integer/push 4 
    integer/push 5 
    f_ctx357~b ctx357 
    stack/unwind 
    f_probe 
    stack/unwind ------------| "probe a/b 4 5" #user-code
]
...compilation time : 36 ms

Target: Linux 

Compiling to native code...
*** Compilation Error: unknown path root variable: red/object/path-parent 
*** in file: %/home/nathan/repos/red/opTest.red 
*** at line: 332 
*** near: [
    set-path* eval-path _context/get ~system as cell! ~script as
]
